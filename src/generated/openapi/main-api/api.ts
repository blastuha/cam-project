/* tslint:disable */
/* eslint-disable */
/**
 * AiCams
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateResponseSchema200
 */
export interface CreateResponseSchema200 {
    /**
     * 
     * @type {boolean}
     * @memberof CreateResponseSchema200
     */
    'success'?: boolean;
    /**
     * 
     * @type {UserGetSchema}
     * @memberof CreateResponseSchema200
     */
    'data': UserGetSchema;
    /**
     * 
     * @type {string}
     * @memberof CreateResponseSchema200
     */
    'error'?: string | null;
}
/**
 * 
 * @export
 * @interface DeleteResponseSchema200
 */
export interface DeleteResponseSchema200 {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteResponseSchema200
     */
    'success'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof DeleteResponseSchema200
     */
    'data'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof DeleteResponseSchema200
     */
    'error'?: string | null;
}
/**
 * 
 * @export
 * @interface GetAllResponseSchema200
 */
export interface GetAllResponseSchema200 {
    /**
     * 
     * @type {boolean}
     * @memberof GetAllResponseSchema200
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<UserGetAllSchema>}
     * @memberof GetAllResponseSchema200
     */
    'data': Array<UserGetAllSchema>;
    /**
     * 
     * @type {string}
     * @memberof GetAllResponseSchema200
     */
    'error'?: string | null;
}
/**
 * 
 * @export
 * @interface GetOneResponseSchema200
 */
export interface GetOneResponseSchema200 {
    /**
     * 
     * @type {boolean}
     * @memberof GetOneResponseSchema200
     */
    'success'?: boolean;
    /**
     * 
     * @type {UserGetSchema}
     * @memberof GetOneResponseSchema200
     */
    'data': UserGetSchema;
    /**
     * 
     * @type {string}
     * @memberof GetOneResponseSchema200
     */
    'error'?: string | null;
}
/**
 * 
 * @export
 * @interface GetVideoAllResponseSchema200
 */
export interface GetVideoAllResponseSchema200 {
    /**
     * 
     * @type {boolean}
     * @memberof GetVideoAllResponseSchema200
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<VideoGetAllSchema>}
     * @memberof GetVideoAllResponseSchema200
     */
    'data': Array<VideoGetAllSchema>;
    /**
     * 
     * @type {string}
     * @memberof GetVideoAllResponseSchema200
     */
    'error'?: string | null;
}
/**
 * 
 * @export
 * @interface GetVideoOneResponseSchema200
 */
export interface GetVideoOneResponseSchema200 {
    /**
     * 
     * @type {boolean}
     * @memberof GetVideoOneResponseSchema200
     */
    'success'?: boolean;
    /**
     * 
     * @type {VideoGetOneDataSchema}
     * @memberof GetVideoOneResponseSchema200
     */
    'data': VideoGetOneDataSchema;
    /**
     * 
     * @type {string}
     * @memberof GetVideoOneResponseSchema200
     */
    'error'?: string | null;
}
/**
 * 
 * @export
 * @interface LoginResponseSchema200
 */
export interface LoginResponseSchema200 {
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponseSchema200
     */
    'success'?: boolean;
    /**
     * 
     * @type {UserTokenSchema}
     * @memberof LoginResponseSchema200
     */
    'data': UserTokenSchema;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseSchema200
     */
    'error'?: string | null;
}
/**
 * 
 * @export
 * @interface LoginResponseSchema401
 */
export interface LoginResponseSchema401 {
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponseSchema401
     */
    'success'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof LoginResponseSchema401
     */
    'data'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof LoginResponseSchema401
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface LoginSchema
 */
export interface LoginSchema {
    /**
     * 
     * @type {string}
     * @memberof LoginSchema
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginSchema
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ManageUserInVideoUserRequestData
 */
export interface ManageUserInVideoUserRequestData {
    /**
     * 
     * @type {string}
     * @memberof ManageUserInVideoUserRequestData
     */
    'user_in_video_data_id': string;
    /**
     * 
     * @type {string}
     * @memberof ManageUserInVideoUserRequestData
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface ManageVideoResponseSchema200
 */
export interface ManageVideoResponseSchema200 {
    /**
     * 
     * @type {boolean}
     * @memberof ManageVideoResponseSchema200
     */
    'success'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ManageVideoResponseSchema200
     */
    'data'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof ManageVideoResponseSchema200
     */
    'error'?: string | null;
}
/**
 * 
 * @export
 * @interface ResponseSchema200
 */
export interface ResponseSchema200 {
    /**
     * 
     * @type {boolean}
     * @memberof ResponseSchema200
     */
    'success'?: boolean;
    /**
     * 
     * @type {UserMeSchema}
     * @memberof ResponseSchema200
     */
    'data': UserMeSchema;
    /**
     * 
     * @type {string}
     * @memberof ResponseSchema200
     */
    'error'?: string | null;
}
/**
 * 
 * @export
 * @interface ResponseSchema401
 */
export interface ResponseSchema401 {
    /**
     * 
     * @type {boolean}
     * @memberof ResponseSchema401
     */
    'success'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ResponseSchema401
     */
    'data'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseSchema401
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ResponseSchemaVideo401
 */
export interface ResponseSchemaVideo401 {
    /**
     * 
     * @type {boolean}
     * @memberof ResponseSchemaVideo401
     */
    'success'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ResponseSchemaVideo401
     */
    'data'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseSchemaVideo401
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UserGetAllSchema
 */
export interface UserGetAllSchema {
    /**
     * 
     * @type {string}
     * @memberof UserGetAllSchema
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserGetAllSchema
     */
    'last_name'?: string | null;
    /**
     * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
     * @type {boolean}
     * @memberof UserGetAllSchema
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserGetAllSchema
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserGetSchema
 */
export interface UserGetSchema {
    /**
     * 
     * @type {string}
     * @memberof UserGetSchema
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserGetSchema
     */
    'last_name'?: string | null;
    /**
     * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
     * @type {boolean}
     * @memberof UserGetSchema
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserGetSchema
     */
    'date_joined'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetSchema
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetSchema
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserGetSchema
     */
    'image'?: string | null;
}
/**
 * 
 * @export
 * @interface UserInVideoDataGroupData
 */
export interface UserInVideoDataGroupData {
    /**
     * 
     * @type {string}
     * @memberof UserInVideoDataGroupData
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UserInVideoDataGroupData
     */
    'user_id': string | null;
    /**
     * 
     * @type {number}
     * @memberof UserInVideoDataGroupData
     */
    'total_time': number;
    /**
     * 
     * @type {number}
     * @memberof UserInVideoDataGroupData
     */
    'total_percent': number;
    /**
     * 
     * @type {Array<UserInVideoOneSchema>}
     * @memberof UserInVideoDataGroupData
     */
    'timings': Array<UserInVideoOneSchema>;
}
/**
 * 
 * @export
 * @interface UserInVideoOneSchema
 */
export interface UserInVideoOneSchema {
    /**
     * 
     * @type {string}
     * @memberof UserInVideoOneSchema
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserInVideoOneSchema
     */
    'track_id': number;
    /**
     * 
     * @type {string}
     * @memberof UserInVideoOneSchema
     */
    'data_group_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserInVideoOneSchema
     */
    'dt_start': string;
    /**
     * 
     * @type {string}
     * @memberof UserInVideoOneSchema
     */
    'dt_end': string;
}
/**
 * 
 * @export
 * @interface UserMeSchema
 */
export interface UserMeSchema {
    /**
     * 
     * @type {string}
     * @memberof UserMeSchema
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserMeSchema
     */
    'username': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserMeSchema
     */
    'is_admin': boolean;
}
/**
 * 
 * @export
 * @interface UserPutSchema
 */
export interface UserPutSchema {
    /**
     * 
     * @type {string}
     * @memberof UserPutSchema
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPutSchema
     */
    'last_name'?: string | null;
    /**
     * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
     * @type {boolean}
     * @memberof UserPutSchema
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserPutSchema
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPutSchema
     */
    'image'?: string | null;
}
/**
 * 
 * @export
 * @interface UserTokenSchema
 */
export interface UserTokenSchema {
    /**
     * 
     * @type {string}
     * @memberof UserTokenSchema
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface VideoAnalyzeRequestData
 */
export interface VideoAnalyzeRequestData {
    /**
     * 
     * @type {number}
     * @memberof VideoAnalyzeRequestData
     */
    'max_tasks'?: number;
    /**
     * 
     * @type {number}
     * @memberof VideoAnalyzeRequestData
     */
    'track_revalidation_seconds'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof VideoAnalyzeRequestData
     */
    'face_recognition_model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoAnalyzeRequestData
     */
    'face_detector_model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoAnalyzeRequestData
     */
    'face_normalization_type'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VideoAnalyzeRequestData
     */
    'face_align'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof VideoAnalyzeRequestData
     */
    'yolo_model'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof VideoAnalyzeRequestData
     */
    'conf_rate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof VideoAnalyzeRequestData
     */
    'user_diapasons_inline_seconds'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof VideoAnalyzeRequestData
     */
    'unknown_tracks_diapasons_discard_seconds'?: number | null;
}
/**
 * 
 * @export
 * @interface VideoGetAllSchema
 */
export interface VideoGetAllSchema {
    /**
     * 
     * @type {string}
     * @memberof VideoGetAllSchema
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VideoGetAllSchema
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoGetAllSchema
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof VideoGetAllSchema
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof VideoGetAllSchema
     */
    'date_start': string;
    /**
     * 
     * @type {string}
     * @memberof VideoGetAllSchema
     */
    'date_end': string;
    /**
     * 
     * @type {string}
     * @memberof VideoGetAllSchema
     */
    'last_task_id'?: string | null;
}
/**
 * 
 * @export
 * @interface VideoGetOneDataSchema
 */
export interface VideoGetOneDataSchema {
    /**
     * 
     * @type {VideoGetOneSchema}
     * @memberof VideoGetOneDataSchema
     */
    'video_data': VideoGetOneSchema;
    /**
     * 
     * @type {{ [key: string]: UserGetAllSchema; }}
     * @memberof VideoGetOneDataSchema
     */
    'users': { [key: string]: UserGetAllSchema; } | null;
    /**
     * 
     * @type {Array<UserInVideoDataGroupData>}
     * @memberof VideoGetOneDataSchema
     */
    'fragments': Array<UserInVideoDataGroupData> | null;
}
/**
 * 
 * @export
 * @interface VideoGetOneSchema
 */
export interface VideoGetOneSchema {
    /**
     * 
     * @type {string}
     * @memberof VideoGetOneSchema
     */
    'process_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoGetOneSchema
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VideoGetOneSchema
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoGetOneSchema
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof VideoGetOneSchema
     */
    'filepath': string;
    /**
     * 
     * @type {string}
     * @memberof VideoGetOneSchema
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof VideoGetOneSchema
     */
    'date_start': string;
    /**
     * 
     * @type {string}
     * @memberof VideoGetOneSchema
     */
    'date_end': string;
    /**
     * 
     * @type {string}
     * @memberof VideoGetOneSchema
     */
    'scanned_at': string;
    /**
     * 
     * @type {string}
     * @memberof VideoGetOneSchema
     */
    'process_start_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoGetOneSchema
     */
    'process_end_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoGetOneSchema
     */
    'result_video_filepath'?: string | null;
}

/**
 * AnalyzerApi - axios parameter creator
 * @export
 */
export const AnalyzerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получить список всех видеофайлов
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analyzer/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppJwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить свойства видеофайла по его id
         * @summary Get One
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerGetOne: async (videoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('analyzerGetOne', 'videoId', videoId)
            const localVarPath = `/api/v1/analyzer/{video_id}`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppJwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить видео стрим работы над видеофайлом
         * @summary Get Processing Video Stream
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerGetProcessStream: async (videoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('analyzerGetProcessStream', 'videoId', videoId)
            const localVarPath = `/api/v1/analyzer/process/{video_id}`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменить юзера у фрагмента анализа данных
         * @summary Manage User In Video Data User
         * @param {ManageUserInVideoUserRequestData} manageUserInVideoUserRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerManageUserInVideoData: async (manageUserInVideoUserRequestData: ManageUserInVideoUserRequestData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'manageUserInVideoUserRequestData' is not null or undefined
            assertParamExists('analyzerManageUserInVideoData', 'manageUserInVideoUserRequestData', manageUserInVideoUserRequestData)
            const localVarPath = `/api/v1/analyzer/manage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppJwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manageUserInVideoUserRequestData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запуск процесса анализа видео файлов
         * @summary Run Video Analyze
         * @param {VideoAnalyzeRequestData} videoAnalyzeRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerRunVideosAnalyze: async (videoAnalyzeRequestData: VideoAnalyzeRequestData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoAnalyzeRequestData' is not null or undefined
            assertParamExists('analyzerRunVideosAnalyze', 'videoAnalyzeRequestData', videoAnalyzeRequestData)
            const localVarPath = `/api/v1/analyzer/system/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AICamsAdminAuth required
            await setApiKeyToObject(localVarHeaderParameter, "aicams-x-admin-secret", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(videoAnalyzeRequestData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Остановка процесса анализа всех видео файлов
         * @summary Stop All Video Analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerStopAllVideosAnalyze: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analyzer/system/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AICamsAdminAuth required
            await setApiKeyToObject(localVarHeaderParameter, "aicams-x-admin-secret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отсновка процесса анализа видео файла
         * @summary Stop Video Analyze
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerStopVideosAnalyze: async (videoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('analyzerStopVideosAnalyze', 'videoId', videoId)
            const localVarPath = `/api/v1/analyzer/system/{video_id}`
                .replace(`{${"video_id"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AICamsAdminAuth required
            await setApiKeyToObject(localVarHeaderParameter, "aicams-x-admin-secret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyzerApi - functional programming interface
 * @export
 */
export const AnalyzerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyzerApiAxiosParamCreator(configuration)
    return {
        /**
         * Получить список всех видеофайлов
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzerGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVideoAllResponseSchema200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzerGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyzerApi.analyzerGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить свойства видеофайла по его id
         * @summary Get One
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzerGetOne(videoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVideoOneResponseSchema200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzerGetOne(videoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyzerApi.analyzerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить видео стрим работы над видеофайлом
         * @summary Get Processing Video Stream
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzerGetProcessStream(videoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzerGetProcessStream(videoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyzerApi.analyzerGetProcessStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Изменить юзера у фрагмента анализа данных
         * @summary Manage User In Video Data User
         * @param {ManageUserInVideoUserRequestData} manageUserInVideoUserRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzerManageUserInVideoData(manageUserInVideoUserRequestData: ManageUserInVideoUserRequestData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManageVideoResponseSchema200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzerManageUserInVideoData(manageUserInVideoUserRequestData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyzerApi.analyzerManageUserInVideoData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Запуск процесса анализа видео файлов
         * @summary Run Video Analyze
         * @param {VideoAnalyzeRequestData} videoAnalyzeRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzerRunVideosAnalyze(videoAnalyzeRequestData: VideoAnalyzeRequestData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzerRunVideosAnalyze(videoAnalyzeRequestData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyzerApi.analyzerRunVideosAnalyze']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Остановка процесса анализа всех видео файлов
         * @summary Stop All Video Analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzerStopAllVideosAnalyze(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzerStopAllVideosAnalyze(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyzerApi.analyzerStopAllVideosAnalyze']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отсновка процесса анализа видео файла
         * @summary Stop Video Analyze
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzerStopVideosAnalyze(videoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzerStopVideosAnalyze(videoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyzerApi.analyzerStopVideosAnalyze']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyzerApi - factory interface
 * @export
 */
export const AnalyzerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyzerApiFp(configuration)
    return {
        /**
         * Получить список всех видеофайлов
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerGetAll(options?: any): AxiosPromise<GetVideoAllResponseSchema200> {
            return localVarFp.analyzerGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Получить свойства видеофайла по его id
         * @summary Get One
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerGetOne(videoId: string, options?: any): AxiosPromise<GetVideoOneResponseSchema200> {
            return localVarFp.analyzerGetOne(videoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить видео стрим работы над видеофайлом
         * @summary Get Processing Video Stream
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerGetProcessStream(videoId: string, options?: any): AxiosPromise<void> {
            return localVarFp.analyzerGetProcessStream(videoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Изменить юзера у фрагмента анализа данных
         * @summary Manage User In Video Data User
         * @param {ManageUserInVideoUserRequestData} manageUserInVideoUserRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerManageUserInVideoData(manageUserInVideoUserRequestData: ManageUserInVideoUserRequestData, options?: any): AxiosPromise<ManageVideoResponseSchema200> {
            return localVarFp.analyzerManageUserInVideoData(manageUserInVideoUserRequestData, options).then((request) => request(axios, basePath));
        },
        /**
         * Запуск процесса анализа видео файлов
         * @summary Run Video Analyze
         * @param {VideoAnalyzeRequestData} videoAnalyzeRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerRunVideosAnalyze(videoAnalyzeRequestData: VideoAnalyzeRequestData, options?: any): AxiosPromise<object> {
            return localVarFp.analyzerRunVideosAnalyze(videoAnalyzeRequestData, options).then((request) => request(axios, basePath));
        },
        /**
         * Остановка процесса анализа всех видео файлов
         * @summary Stop All Video Analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerStopAllVideosAnalyze(options?: any): AxiosPromise<object> {
            return localVarFp.analyzerStopAllVideosAnalyze(options).then((request) => request(axios, basePath));
        },
        /**
         * Отсновка процесса анализа видео файла
         * @summary Stop Video Analyze
         * @param {string} videoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzerStopVideosAnalyze(videoId: string, options?: any): AxiosPromise<object> {
            return localVarFp.analyzerStopVideosAnalyze(videoId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyzerApi - object-oriented interface
 * @export
 * @class AnalyzerApi
 * @extends {BaseAPI}
 */
export class AnalyzerApi extends BaseAPI {
    /**
     * Получить список всех видеофайлов
     * @summary Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyzerApi
     */
    public analyzerGetAll(options?: RawAxiosRequestConfig) {
        return AnalyzerApiFp(this.configuration).analyzerGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить свойства видеофайла по его id
     * @summary Get One
     * @param {string} videoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyzerApi
     */
    public analyzerGetOne(videoId: string, options?: RawAxiosRequestConfig) {
        return AnalyzerApiFp(this.configuration).analyzerGetOne(videoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить видео стрим работы над видеофайлом
     * @summary Get Processing Video Stream
     * @param {string} videoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyzerApi
     */
    public analyzerGetProcessStream(videoId: string, options?: RawAxiosRequestConfig) {
        return AnalyzerApiFp(this.configuration).analyzerGetProcessStream(videoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Изменить юзера у фрагмента анализа данных
     * @summary Manage User In Video Data User
     * @param {ManageUserInVideoUserRequestData} manageUserInVideoUserRequestData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyzerApi
     */
    public analyzerManageUserInVideoData(manageUserInVideoUserRequestData: ManageUserInVideoUserRequestData, options?: RawAxiosRequestConfig) {
        return AnalyzerApiFp(this.configuration).analyzerManageUserInVideoData(manageUserInVideoUserRequestData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Запуск процесса анализа видео файлов
     * @summary Run Video Analyze
     * @param {VideoAnalyzeRequestData} videoAnalyzeRequestData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyzerApi
     */
    public analyzerRunVideosAnalyze(videoAnalyzeRequestData: VideoAnalyzeRequestData, options?: RawAxiosRequestConfig) {
        return AnalyzerApiFp(this.configuration).analyzerRunVideosAnalyze(videoAnalyzeRequestData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Остановка процесса анализа всех видео файлов
     * @summary Stop All Video Analyze
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyzerApi
     */
    public analyzerStopAllVideosAnalyze(options?: RawAxiosRequestConfig) {
        return AnalyzerApiFp(this.configuration).analyzerStopAllVideosAnalyze(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отсновка процесса анализа видео файла
     * @summary Stop Video Analyze
     * @param {string} videoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyzerApi
     */
    public analyzerStopVideosAnalyze(videoId: string, options?: RawAxiosRequestConfig) {
        return AnalyzerApiFp(this.configuration).analyzerStopVideosAnalyze(videoId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScannerApi - axios parameter creator
 * @export
 */
export const ScannerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Сканирование новых файлов в папке видеофайлов
         * @summary Scan Videos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scannerScanVideos: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/scanner/videos/scan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AICamsAdminAuth required
            await setApiKeyToObject(localVarHeaderParameter, "aicams-x-admin-secret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Список исходных видеофайлов
         * @summary Videos List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scannerVideosList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/scanner/videos/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AICamsAdminAuth required
            await setApiKeyToObject(localVarHeaderParameter, "aicams-x-admin-secret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScannerApi - functional programming interface
 * @export
 */
export const ScannerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScannerApiAxiosParamCreator(configuration)
    return {
        /**
         * Сканирование новых файлов в папке видеофайлов
         * @summary Scan Videos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scannerScanVideos(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scannerScanVideos(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScannerApi.scannerScanVideos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Список исходных видеофайлов
         * @summary Videos List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scannerVideosList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scannerVideosList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScannerApi.scannerVideosList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScannerApi - factory interface
 * @export
 */
export const ScannerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScannerApiFp(configuration)
    return {
        /**
         * Сканирование новых файлов в папке видеофайлов
         * @summary Scan Videos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scannerScanVideos(options?: any): AxiosPromise<object> {
            return localVarFp.scannerScanVideos(options).then((request) => request(axios, basePath));
        },
        /**
         * Список исходных видеофайлов
         * @summary Videos List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scannerVideosList(options?: any): AxiosPromise<object> {
            return localVarFp.scannerVideosList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScannerApi - object-oriented interface
 * @export
 * @class ScannerApi
 * @extends {BaseAPI}
 */
export class ScannerApi extends BaseAPI {
    /**
     * Сканирование новых файлов в папке видеофайлов
     * @summary Scan Videos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScannerApi
     */
    public scannerScanVideos(options?: RawAxiosRequestConfig) {
        return ScannerApiFp(this.configuration).scannerScanVideos(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Список исходных видеофайлов
     * @summary Videos List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScannerApi
     */
    public scannerVideosList(options?: RawAxiosRequestConfig) {
        return ScannerApiFp(this.configuration).scannerVideosList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Удаление пользователя из системы
         * @summary Delete
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('_delete', 'userId', userId)
            const localVarPath = `/api/v1/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppJwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создание пользователя в системе
         * @summary Create
         * @param {UserPutSchema} userPutSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (userPutSchema: UserPutSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPutSchema' is not null or undefined
            assertParamExists('create', 'userPutSchema', userPutSchema)
            const localVarPath = `/api/v1/user/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppJwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPutSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить всех пользователей
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppJwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить текущего авторизованного пользователя.
         * @summary Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppJwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить данные пользователя по ID
         * @summary Get One
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/api/v1/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppJwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Авторизация в системе
         * @summary Login
         * @param {LoginSchema} loginSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginSchema: LoginSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginSchema' is not null or undefined
            assertParamExists('login', 'loginSchema', loginSchema)
            const localVarPath = `/api/v1/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновление пользователя в системе
         * @summary Update
         * @param {string} userId 
         * @param {UserPutSchema} userPutSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (userId: string, userPutSchema: UserPutSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('update', 'userId', userId)
            // verify required parameter 'userPutSchema' is not null or undefined
            assertParamExists('update', 'userPutSchema', userPutSchema)
            const localVarPath = `/api/v1/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppJwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPutSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Удаление пользователя из системы
         * @summary Delete
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponseSchema200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создание пользователя в системе
         * @summary Create
         * @param {UserPutSchema} userPutSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(userPutSchema: UserPutSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateResponseSchema200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(userPutSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить всех пользователей
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllResponseSchema200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить текущего авторизованного пользователя.
         * @summary Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseSchema200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получить данные пользователя по ID
         * @summary Get One
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOneResponseSchema200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Авторизация в системе
         * @summary Login
         * @param {LoginSchema} loginSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginSchema: LoginSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseSchema200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновление пользователя в системе
         * @summary Update
         * @param {string} userId 
         * @param {UserPutSchema} userPutSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(userId: string, userPutSchema: UserPutSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateResponseSchema200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(userId, userPutSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Удаление пользователя из системы
         * @summary Delete
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(userId: string, options?: any): AxiosPromise<DeleteResponseSchema200> {
            return localVarFp._delete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Создание пользователя в системе
         * @summary Create
         * @param {UserPutSchema} userPutSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(userPutSchema: UserPutSchema, options?: any): AxiosPromise<CreateResponseSchema200> {
            return localVarFp.create(userPutSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить всех пользователей
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(options?: any): AxiosPromise<GetAllResponseSchema200> {
            return localVarFp.getAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Получить текущего авторизованного пользователя.
         * @summary Get Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<ResponseSchema200> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * Получить данные пользователя по ID
         * @summary Get One
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: any): AxiosPromise<GetOneResponseSchema200> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Авторизация в системе
         * @summary Login
         * @param {LoginSchema} loginSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginSchema: LoginSchema, options?: any): AxiosPromise<LoginResponseSchema200> {
            return localVarFp.login(loginSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновление пользователя в системе
         * @summary Update
         * @param {string} userId 
         * @param {UserPutSchema} userPutSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(userId: string, userPutSchema: UserPutSchema, options?: any): AxiosPromise<CreateResponseSchema200> {
            return localVarFp.update(userId, userPutSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Удаление пользователя из системы
     * @summary Delete
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public _delete(userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration)._delete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создание пользователя в системе
     * @summary Create
     * @param {UserPutSchema} userPutSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public create(userPutSchema: UserPutSchema, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).create(userPutSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить всех пользователей
     * @summary Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getAll(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить текущего авторизованного пользователя.
     * @summary Get Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMe(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить данные пользователя по ID
     * @summary Get One
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Авторизация в системе
     * @summary Login
     * @param {LoginSchema} loginSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public login(loginSchema: LoginSchema, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).login(loginSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновление пользователя в системе
     * @summary Update
     * @param {string} userId 
     * @param {UserPutSchema} userPutSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public update(userId: string, userPutSchema: UserPutSchema, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).update(userId, userPutSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



